#!/usr/bin/env python3

"""
 The turtle_interpret node translates a custom velocity message into a
 geometry_msgs/Twist that can be used by the turtlesim
SUBSCRIBES:
  TurtleVel
"""

import rospy
from turtle_control.msg import TurtleVel
from turtle_control.srv import VelTranslate
from geometry_msgs.msg import Twist , Vector3
from turtlesim.srv import Spawn, SpawnRequest
from crazy_turtle.srv import Switch, SwitchResponse
from turtlesim.srv import Kill
from random import uniform



def turtle_twist(xdot, omega):
    """ Create a twist suitable for a turtle

        Args:
           xdot (float) : the forward velocity
           omega (float) : the angular velocity

        Returns:
           Twist - a 2D twist object corresponding to linear/angular velocity
    """
    return Twist(linear = Vector3(x = xdot, y = 0, z = 0),
                  angular = Vector3(x = 0, y = 0, z = omega))

#TODO - remove comments

class Turtle_Interpret:
    """ Publishes movement geometry_msgs/Twist commands at a fixed rate 
    """
    def __init__(self):
        # self.nsteps = 0
        self.direction = 1
        self.velocity = 5 #TODO change number
        self.sub = rospy.Subscriber("turtle_vel", TurtleVel, self.turtle_vel_callback)
        self.pub = rospy.Publisher('cmd_vel', Twist, queue_size = 10)
        self.serv = rospy.Service("vel_translate", VelTranslate, self.vel_translate_callback)
        # self.switch = rospy.Service("switch", Switch, self.switch_callback)
        # self.kill = rospy.ServiceProxy("kill", Kill)
        # self.spawn = rospy.ServiceProxy("spawn", Spawn)
        # self.tmr = rospy.Timer(rospy.Duration(0.01), self.timer_callback)


    def turtle_vel_callback(self, data):
        rospy.logdebug(f"Message: {data}")
        twist = turtle_twist(data.linear, data.angular)
        self.pub.publish(twist)


    def vel_translate_callback (self, twist_msg):
        rospy.logdebug(f"vel_translate_callback: {data}") #TODO remove
        if twist_msg.twist.linear.y != 0 or twist_msg.twist.linear.z != 0 or twist_msg.twist.angular.x != 0 or twist_msg.twist.angular.y != 0:
            return None
        return TurtleVel(linear = twist_msg.twist.linear.x, angular = twist_msg.twist.angular.z)




    def switch_callback(self, pose): #TODO
        """ Callback function for the switch service
        
        Kills turtle1 and respawns it an a new location

         Args:
          pose (SwitchRequest): the mixed_up field contains
             x, y, linear and angular velocity components
             that are used to determine the new turtle location

        Returns:
           A SwitchResponse, containing the new x and y position
        """
        self.kill("turtle1")
        # The new position of the turtle is intentionally scrambled from a weird message
        newx = pose.mixed_up.x * pose.mixed_up.angular_velocity
        newy = pose.mixed_up.y * pose.mixed_up.linear_velocity
        self.spawn(x = newx, y = newy, theta = pose.mixed_up.theta, name = "turtle1")
        return SwitchResponse(x = newx, y = newy)

    def timer_callback(self, event): #TODO
        """ Handle the timer callback.

        Args:
          event (TimerEvent): This timer doesn't use any of the event info.
        """
        twist = turtle_twist(self.direction * self.velocity, uniform(-20, 20))

        self.nsteps += 1
        if self.nsteps > 200:
            self.nsteps = 0
            self.direction *= -1

        self.pub.publish(twist)

def main():
    """ The main() function. """
    rospy.init_node('turtle_interpret', log_level=rospy.DEBUG)
    Turtle_Interpret()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass













# if __name__ == "__main__":
#     # rospy.init_node('turtle_interpret', anonymous=True, log_level=rospy.DEBUG)
#     # velocity_publisher = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)
#     # rospy.Subscriber("turtle_vel", TurtleVel, turtle_vel_callback)
#     turtle_vel_callback("123")#TODO remove
#     while not rospy.is_shutdown():
#         rospy.logdebug("Degug message")
#         rate = rospy.Rate(1) #TODO remove
#         rate.sleep()
#     rospy.spin()


    # rospy.Subscriber("turtle1/pose", Pose, callback)
    # rospy.ServiceProxy("turtle1/teleport_absolute", TeleportAbsolute)
    # rospy.init_node("quadrant")



        # sub = rospy.Subscriber("turtle_vel", Twist, queue_size = 10)
        # # pub = rospy.publisher("turtle_vel", Twist, queue_size = 10)
        # # rospy.ServiceProxy("turtle_control/teleport_absolute", TeleportAbsolute)
        # rospy.init_node("turtle_interpret")
        # rate = rospy.Rate(1)
        # while not rospy.is_shutdown():
        #     rospy.logdebug("Hello")
    #     #     pub.publish(Twist())
    #     #     rate.sleep()
    # rospy.spin()